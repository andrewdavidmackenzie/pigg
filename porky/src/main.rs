#![no_std]
#![no_main]

use crate::ssid::{
    MARKER_LENGTH, SSID_NAME, SSID_NAME_LENGTH, SSID_PASS, SSID_PASS_LENGTH, SSID_SECURITY,
};
use cyw43::Control;
use cyw43::NetDriver;
use cyw43_pio::PioSpi;
use defmt_rtt as _;
use embassy_executor::Spawner;
use embassy_net::{
    tcp::client::{TcpClient, TcpClientState},
    Stack, StackResources,
};
use embassy_rp::bind_interrupts;
use embassy_rp::flash::Async;
use embassy_rp::gpio::{Level, Output};
use embassy_rp::peripherals::USB;
use embassy_rp::peripherals::{DMA_CH0, PIO0};
use embassy_rp::pio::{InterruptHandler, Pio};
use embassy_rp::usb::{Driver, InterruptHandler as USBInterruptHandler};
use embassy_time::{Duration, Timer};
use faster_hex::hex_encode;
use log::{error, info};
use panic_probe as _;
use static_cell::StaticCell;

/// The ssid config generated by build.rs in "$OUT_DIR/ssid.rs"
mod ssid {
    include!(concat!(env!("OUT_DIR"), "/ssid.rs"));
}

const FLASH_SIZE: usize = 2 * 1024 * 1024;

const WIFI_JOIN_RETRY_ATTEMPT_LIMIT: usize = 3;

bind_interrupts!(struct Irqs {
    PIO0_IRQ_0 => InterruptHandler<PIO0>;
    USBCTRL_IRQ => USBInterruptHandler<USB>;
});

#[embassy_executor::task]
async fn wifi_task(
    runner: cyw43::Runner<'static, Output<'static>, PioSpi<'static, PIO0, 0, DMA_CH0>>,
) -> ! {
    runner.run().await
}

#[embassy_executor::task]
async fn net_task(stack: &'static Stack<NetDriver<'static>>) -> ! {
    stack.run().await
}

#[embassy_executor::task]
async fn logger_task(driver: Driver<'static, USB>) {
    embassy_usb_logger::run!(1024, log::LevelFilter::Info, driver);
}

async fn wait_for_dhcp(stack: &Stack<NetDriver<'static>>) {
    info!("Waiting for DHCP...");
    while !stack.is_config_up() {
        Timer::after_millis(100).await;
    }
    info!("DHCP is now up!");
}

async fn message_loop<'a>(
    _device_id_hex: &[u8],
    stack: &Stack<NetDriver<'static>>,
    control: &mut Control<'_>,
) {
    let client_state: TcpClientState<2, 1024, 1024> = TcpClientState::new();
    let _client = TcpClient::new(stack, &client_state);
    // let mut rx_buf = [0; 4096];

    info!("Starting message loop");
    loop {
        // LED on
        control.gpio_set(0, true).await;

        Timer::after(Duration::from_secs(1)).await;

        // LED off
        control.gpio_set(0, false).await;
    }
}

async fn join_wifi(
    control: &mut Control<'_>,
    stack: &Stack<NetDriver<'static>>,
    ssid_name: &str,
    ssid_pass: &str,
) -> bool {
    let mut attempt = 1;
    while attempt <= WIFI_JOIN_RETRY_ATTEMPT_LIMIT {
        info!("Attempt #{} to join wifi network: '{}'", attempt, ssid_name);
        let result = match SSID_SECURITY {
            "open" => control.join_open(ssid_name).await,
            "wpa2" => control.join_wpa2(ssid_name, ssid_pass).await,
            "wpa3" => control.join_wpa3(ssid_name, ssid_pass).await,
            _ => {
                error!("Security '{}' is not supported", SSID_SECURITY);
                return false;
            }
        };

        match result {
            Ok(_) => {
                info!("Joined wifi network: '{}'", ssid_name);
                wait_for_dhcp(stack).await;
                control.gpio_set(0, false).await;
                return true;
            }
            Err(e) => {
                attempt += 1;
                error!("Error joining wifi: {:?}", e);
            }
        }
    }

    false
}

#[embassy_executor::main]
async fn main(spawner: Spawner) {
    let p = embassy_rp::init(Default::default());
    let driver = Driver::new(p.USB, Irqs);
    let fw = include_bytes!("../assets/43439A0.bin");
    let clm = include_bytes!("../assets/43439A0_clm.bin");
    let pwr = Output::new(p.PIN_23, Level::Low);
    let cs = Output::new(p.PIN_25, Level::High);
    let mut pio = Pio::new(p.PIO0, Irqs);
    let spi = PioSpi::new(
        &mut pio.common,
        pio.sm0,
        pio.irq0,
        cs,
        p.PIN_24,
        p.PIN_29,
        p.DMA_CH0,
    );

    static STATE: StaticCell<cyw43::State> = StaticCell::new();
    let state = STATE.init(cyw43::State::new());
    let (net_device, mut control, runner) = cyw43::new(state, pwr, spi, fw).await;

    spawner.spawn(wifi_task(runner)).unwrap();
    spawner.spawn(logger_task(driver)).unwrap();

    control.init(clm).await;
    control
        .set_power_management(cyw43::PowerManagementMode::PowerSave)
        .await;

    // Switch on led to show we are up and running
    control.gpio_set(0, true).await;

    // Get a unique device id - in this case an eight-byte ID from flash rendered as hex string
    let mut device_id = [0; 8];
    let mut flash = embassy_rp::flash::Flash::<_, Async, { FLASH_SIZE }>::new(p.FLASH, p.DMA_CH1);
    flash.blocking_unique_id(&mut device_id).unwrap();
    let mut device_id_hex: [u8; 16] = [0; 16];
    hex_encode(&device_id, &mut device_id_hex).unwrap();
    info!(
        "Device ID = {}",
        core::str::from_utf8(&device_id_hex).unwrap()
    );

    let dhcp_config = embassy_net::Config::dhcpv4(Default::default());

    static RESOURCES: StaticCell<StackResources<3>> = StaticCell::new();
    let resources = RESOURCES.init(StackResources::new());

    // Generate random seed
    let seed = 0x0123_4567_89ab_cdef;
    static STACK: StaticCell<Stack<NetDriver<'static>>> = StaticCell::new();
    let stack = STACK.init(Stack::new(net_device, dhcp_config, resources, seed));

    spawner.spawn(net_task(stack)).unwrap();

    let ssid_name = SSID_NAME[MARKER_LENGTH..(MARKER_LENGTH + SSID_NAME_LENGTH)].trim();
    let ssid_pass = SSID_PASS[MARKER_LENGTH..(MARKER_LENGTH + SSID_PASS_LENGTH)].trim();

    if join_wifi(&mut control, &stack, ssid_name, ssid_pass).await {
        message_loop(&device_id_hex, stack, &mut control).await;
    }

    info!("Exiting");
}
