#![no_std]
#![no_main]

use crate::ssid::{
    MARKER_LENGTH, SSID_NAME, SSID_NAME_LENGTH, SSID_PASS, SSID_PASS_LENGTH, SSID_SECURITY,
};
use core::str::from_utf8;
use cyw43::Control;
use cyw43::NetDriver;
use cyw43_pio::PioSpi;
use defmt::{error, info, warn};
use defmt_rtt as _;
use embassy_executor::Spawner;
use embassy_net::tcp::TcpSocket;
use embassy_net::Ipv4Address;
use embassy_net::{
    tcp::client::{TcpClient, TcpClientState},
    Stack, StackResources,
};
use embassy_rp::bind_interrupts;
use embassy_rp::flash::Async;
use embassy_rp::flash::Flash;
use embassy_rp::gpio::{Level, Output};
use embassy_rp::peripherals::USB;
use embassy_rp::peripherals::{DMA_CH0, PIO0};
use embassy_rp::pio::{InterruptHandler, Pio};
use embassy_rp::usb::InterruptHandler as USBInterruptHandler;
use embassy_time::{Duration, Timer};
use embedded_io_async::Write;
use faster_hex::hex_encode;
use panic_probe as _;
use static_cell::StaticCell;

/// The ssid config generated by build.rs in "$OUT_DIR/ssid.rs"
mod ssid {
    include!(concat!(env!("OUT_DIR"), "/ssid.rs"));
}

#[path = "../../src/hw"]
mod hw;

const LED: u8 = 0;

const ON: bool = true;
const OFF: bool = false;

const FLASH_SIZE: usize = 2 * 1024 * 1024;

const WIFI_JOIN_RETRY_ATTEMPT_LIMIT: usize = 3;

bind_interrupts!(struct Irqs {
    PIO0_IRQ_0 => InterruptHandler<PIO0>;
    USBCTRL_IRQ => USBInterruptHandler<USB>;
});

#[embassy_executor::task]
async fn wifi_task(
    runner: cyw43::Runner<'static, Output<'static>, PioSpi<'static, PIO0, 0, DMA_CH0>>,
) -> ! {
    runner.run().await
}

#[embassy_executor::task]
async fn net_task(stack: &'static Stack<NetDriver<'static>>) -> ! {
    stack.run().await
}

async fn wait_for_dhcp(stack: &Stack<NetDriver<'static>>) -> Option<Ipv4Address> {
    info!("Waiting for DHCP...");
    while !stack.is_config_up() {
        Timer::after_millis(100).await;
    }
    info!("DHCP is now up!");
    if let Some(if_config) = stack.config_v4() {
        Some(if_config.address.address())
    } else {
        None
    }
}

async fn message_loop<'a>(
    ip_address: Ipv4Address,
    stack: &Stack<NetDriver<'static>>,
    control: &mut Control<'_>,
) {
    let client_state: TcpClientState<2, 1024, 1024> = TcpClientState::new();
    let _client = TcpClient::new(stack, &client_state);

    let mut rx_buffer = [0; 4096];
    let mut tx_buffer = [0; 4096];
    let mut buf = [0; 4096];

    let mut socket = TcpSocket::new(stack, &mut rx_buffer, &mut tx_buffer);
    socket.set_timeout(Some(Duration::from_secs(10)));

    info!("Listening on TCP {}:1234", ip_address);
    if let Err(e) = socket.accept(1234).await {
        error!("TCP accept error: {:?}", e);
        return;
    }

    info!("Received connection from {:?}", socket.remote_endpoint());

    // send hardware description
    let desc = HardwareDescription::default();

    info!("Starting message loop");
    loop {
        // wait for config message
        let n = match socket.read(&mut buf).await {
            Ok(0) => {
                warn!("read EOF");
                break;
            }
            Ok(n) => n,
            Err(e) => {
                warn!("read error: {:?}", e);
                break;
            }
        };

        control.gpio_set(LED, ON).await;
        info!("rxd {}", from_utf8(&buf[..n]).unwrap());

        match socket.write_all(&buf[..n]).await {
            Ok(()) => {}
            Err(e) => {
                warn!("write error: {:?}", e);
                break;
            }
        };
        control.gpio_set(LED, OFF).await;
    }
    // info!("Exited message loop");
}

async fn join_wifi(
    control: &mut Control<'_>,
    stack: &Stack<NetDriver<'static>>,
    ssid_name: &str,
    ssid_pass: &str,
) -> Option<Ipv4Address> {
    let mut attempt = 1;
    while attempt <= WIFI_JOIN_RETRY_ATTEMPT_LIMIT {
        info!("Attempt #{} to join wifi network: '{}'", attempt, ssid_name);
        let result = match SSID_SECURITY {
            "open" => control.join_open(ssid_name).await,
            "wpa2" => control.join_wpa2(ssid_name, ssid_pass).await,
            "wpa3" => control.join_wpa3(ssid_name, ssid_pass).await,
            _ => {
                error!("Security '{}' is not supported", SSID_SECURITY);
                return None;
            }
        };

        match result {
            Ok(_) => {
                info!("Joined wifi network: '{}'", ssid_name);
                return wait_for_dhcp(stack).await;
            }
            Err(_) => {
                attempt += 1;
                warn!("Failed to join wifi, retrying");
            }
        }
    }

    error!(
        "Failed to join Wifi after {} reties",
        WIFI_JOIN_RETRY_ATTEMPT_LIMIT
    );
    None
}

fn log_device_id(device_id: [u8; 8]) {
    let mut device_id_hex: [u8; 16] = [0; 16];
    hex_encode(&device_id, &mut device_id_hex).unwrap();
    info!("Device ID = {}", from_utf8(&device_id_hex).unwrap());
}

/*
Wifi scanning

We could use this to program the ssid config with a list of ssids, and when
it cannot connect via one, it scans to see if another one it knows is available
and then tries to connect to that.

let mut scanner = control.scan(Default::default()).await;
while let Some(bss) = scanner.next().await {
    if let Ok(ssid_str) = str::from_utf8(&bss.ssid) {
    info!("scanned {} == {:x}", ssid_str, bss.bssid);
    }
}

 */

#[embassy_executor::main]
async fn main(spawner: Spawner) {
    let p = embassy_rp::init(Default::default());
    let fw = include_bytes!("../assets/43439A0.bin");
    let clm = include_bytes!("../assets/43439A0_clm.bin");
    let pwr = Output::new(p.PIN_23, Level::Low);
    let cs = Output::new(p.PIN_25, Level::High);
    let mut pio = Pio::new(p.PIO0, Irqs);
    let spi = PioSpi::new(
        &mut pio.common,
        pio.sm0,
        pio.irq0,
        cs,
        p.PIN_24,
        p.PIN_29,
        p.DMA_CH0,
    );

    static STATE: StaticCell<cyw43::State> = StaticCell::new();
    let state = STATE.init(cyw43::State::new());
    let (net_device, mut control, runner) = cyw43::new(state, pwr, spi, fw).await;

    spawner.spawn(wifi_task(runner)).unwrap();

    control.init(clm).await;
    control
        .set_power_management(cyw43::PowerManagementMode::PowerSave)
        .await;

    // Switch on led to show we are up and running
    control.gpio_set(LED, ON).await;

    // Get a unique device id - in this case an eight-byte ID from flash rendered as hex string
    let mut flash = Flash::<_, Async, { FLASH_SIZE }>::new(p.FLASH, p.DMA_CH1);
    let mut device_id = [0; 8];
    flash.blocking_unique_id(&mut device_id).unwrap();
    log_device_id(device_id);

    let dhcp_config = embassy_net::Config::dhcpv4(Default::default());

    static RESOURCES: StaticCell<StackResources<3>> = StaticCell::new();
    let resources = RESOURCES.init(StackResources::new());

    // Generate random seed
    let seed = 0x0123_4567_89ab_cdef;
    static STACK: StaticCell<Stack<NetDriver<'static>>> = StaticCell::new();
    let stack = STACK.init(Stack::new(net_device, dhcp_config, resources, seed));

    spawner.spawn(net_task(stack)).unwrap();

    let ssid_name = SSID_NAME[MARKER_LENGTH..(MARKER_LENGTH + SSID_NAME_LENGTH)].trim();
    let ssid_pass = SSID_PASS[MARKER_LENGTH..(MARKER_LENGTH + SSID_PASS_LENGTH)].trim();

    while let Some(ip_address) = join_wifi(&mut control, &stack, ssid_name, ssid_pass).await {
        loop {
            message_loop(ip_address, stack, &mut control).await;
            info!("Disconnected");
        }
    }

    info!("Exiting");
    control.gpio_set(LED, OFF).await;
}
