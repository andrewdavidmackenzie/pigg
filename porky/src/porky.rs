#![no_std]
#![no_main]

use crate::ssid::{
    MARKER_LENGTH, SSID_NAME, SSID_NAME_LENGTH, SSID_PASS, SSID_PASS_LENGTH, SSID_SECURITY,
};
use core::str::from_utf8;
use cyw43::Control;
use cyw43::NetDriver;
use cyw43_pio::PioSpi;
use defmt::{error, info, warn};
use defmt_rtt as _;
use embassy_executor::Spawner;
use embassy_net::tcp::TcpSocket;
use embassy_net::Ipv4Address;
use embassy_net::{
    tcp::client::{TcpClient, TcpClientState},
    Stack, StackResources,
};
use embassy_rp::bind_interrupts;
use embassy_rp::flash::Async;
use embassy_rp::flash::Flash;
use embassy_rp::gpio::{Level, Output};
use embassy_rp::peripherals::USB;
use embassy_rp::peripherals::{DMA_CH0, PIO0};
use embassy_rp::pio::{InterruptHandler, Pio};
use embassy_rp::usb::InterruptHandler as USBInterruptHandler;
use embassy_time::Timer;
use embedded_io_async::Write;
use faster_hex::hex_encode;
use heapless::Vec;
use hw_definition::config::HardwareConfigMessage;
use hw_definition::config::HardwareConfigMessage::*;
use hw_definition::description::{HardwareDescription, HardwareDetails, PinDescriptionSet};
use panic_probe as _;
use pin_descriptions::PIN_DESCRIPTIONS;
use static_cell::StaticCell;

/// The ssid config generated by build.rs in "$OUT_DIR/ssid.rs"
mod ssid {
    include!(concat!(env!("OUT_DIR"), "/ssid.rs"));
}

#[path = "../../src/hw_definition/mod.rs"]
mod hw_definition;

mod pin_descriptions;

const FLASH_SIZE: usize = 2 * 1024 * 1024;

const WIFI_JOIN_RETRY_ATTEMPT_LIMIT: usize = 3;

bind_interrupts!(struct Irqs {
    PIO0_IRQ_0 => InterruptHandler<PIO0>;
    USBCTRL_IRQ => USBInterruptHandler<USB>;
});

#[embassy_executor::task]
async fn wifi_task(
    runner: cyw43::Runner<'static, Output<'static>, PioSpi<'static, PIO0, 0, DMA_CH0>>,
) -> ! {
    runner.run().await
}

#[embassy_executor::task]
async fn net_task(stack: &'static Stack<NetDriver<'static>>) -> ! {
    stack.run().await
}

async fn join_wifi(
    control: &mut Control<'_>,
    stack: &Stack<NetDriver<'static>>,
    ssid_name: &str,
    ssid_pass: &str,
) -> Option<Ipv4Address> {
    let mut attempt = 1;
    while attempt <= WIFI_JOIN_RETRY_ATTEMPT_LIMIT {
        info!(
            "Attempt #{} to join wifi network: '{}' with security = '{}'",
            attempt, ssid_name, SSID_SECURITY
        );
        let result = match SSID_SECURITY {
            "open" => control.join_open(ssid_name).await,
            "wpa2" => control.join_wpa2(ssid_name, ssid_pass).await,
            "wpa3" => control.join_wpa3(ssid_name, ssid_pass).await,
            _ => {
                error!("Security '{}' is not supported", SSID_SECURITY);
                return None;
            }
        };

        match result {
            Ok(_) => {
                info!("Joined wifi network: '{}'", ssid_name);
                return wait_for_dhcp(stack).await;
            }
            Err(_) => {
                attempt += 1;
                warn!("Failed to join wifi, retrying");
            }
        }
    }

    error!(
        "Failed to join Wifi after {} reties",
        WIFI_JOIN_RETRY_ATTEMPT_LIMIT
    );
    None
}

/// Wait for the DHCP service to come up and for us to get an IP address
async fn wait_for_dhcp(stack: &Stack<NetDriver<'static>>) -> Option<Ipv4Address> {
    info!("Waiting for DHCP...");
    while !stack.is_config_up() {
        Timer::after_millis(100).await;
    }
    info!("DHCP is now up!");
    if let Some(if_config) = stack.config_v4() {
        Some(if_config.address.address())
    } else {
        None
    }
}

/// Wait for an incoming TCP connection, then respond to it with the [HardwareDescription]
async fn tcp_accept(socket: &mut TcpSocket<'_>, ip_address: &Ipv4Address, device_id: &[u8; 8]) {
    let mut buf = [0; 4096];

    info!("Listening on TCP {}:1234", ip_address);
    if let Err(e) = socket.accept(1234).await {
        error!("TCP accept error: {:?}", e);
        return;
    }

    info!(
        "Received connection from {:?}",
        socket.remote_endpoint().unwrap()
    );

    let mut device_id_hex: [u8; 16] = [0; 16];
    hex_encode(device_id, &mut device_id_hex).unwrap();

    // send hardware description
    let details = HardwareDetails {
        hardware: "foo",
        revision: "foo",
        serial: from_utf8(&device_id_hex).unwrap(),
        model: "Pi Pico W",
    };

    let hw_desc = HardwareDescription {
        details,
        pins: PinDescriptionSet {
            pins: Vec::from_slice(&PIN_DESCRIPTIONS).unwrap(),
        },
    };

    let slice = postcard::to_slice(&hw_desc, &mut buf).unwrap();
    info!("Sending hardware description (length: {})", slice.len());
    socket.write_all(slice).await.unwrap();
}

/// Wait until a message in received on the [TcpSocket] then deserialize it and return it
async fn wait_message(socket: &mut TcpSocket<'_>) -> Option<HardwareConfigMessage> {
    let mut buf = [0; 4096]; // TODO needed?

    // wait for hardware config message
    let n = socket.read(&mut buf).await.ok()?;
    if n == 0 {
        return None;
    }

    postcard::from_bytes(&buf[..n]).ok()
}

/// Apply a config change to the hardware
/// NOTE: Initially the callback to Config/PinConfig change was async, and that compiles and runs
/// but wasn't working - so this uses a sync callback again to fix that, and an async version of
/// send_input_level() for use directly from the async context
async fn apply_config_change(config_change: HardwareConfigMessage, _socket: &mut TcpSocket<'_>) {
    match config_change {
        NewConfig(_config) => {
            info!("New config applied");
            /*
            let wc = writer.clone();
            hardware.apply_config(&config, move |bcm, level| {
                let _ = send_input_level(wc.clone(), bcm, level);
            })?;

            let _ = send_current_input_states(writer.clone(), &config, hardware).await;
             */
        }
        NewPinConfig(bcm, _pin_function) => {
            info!("New pin config for pin #{}", bcm);
            /*
            let _ = hardware.apply_pin_config(bcm, &pin_function, move |bcm, level| {
                let _ = send_input_level(writer.clone(), bcm, level);
            });
             */
        }
        IOLevelChanged(bcm, level_change) => {
            info!(
                "Pin #{} Output level change: {:?}",
                bcm, level_change.new_level
            );
            //            let _ = hardware.set_output_level(bcm, level_change.new_level);
        }
    }
}

/// Enter the message loop, processing config change messages from piggui
async fn message_loop<'a>(
    device_id: [u8; 8],
    ip_address: Ipv4Address,
    stack: &Stack<NetDriver<'static>>,
) {
    let client_state: TcpClientState<2, 1024, 1024> = TcpClientState::new();
    let _client = TcpClient::new(stack, &client_state);

    let mut rx_buffer = [0; 4096];
    let mut tx_buffer = [0; 4096];

    let mut socket = TcpSocket::new(stack, &mut rx_buffer, &mut tx_buffer);
    //socket.set_timeout(Some(Duration::from_secs(10)));

    // wait for a connection from `piggui`
    tcp_accept(&mut socket, &ip_address, &device_id).await;

    info!("Entering message loop");
    loop {
        if let Some(config_message) = wait_message(&mut socket).await {
            let _ = apply_config_change(config_message, &mut socket).await;
        }

        /*
        match socket.write_all(&buf[..n]).await {
            Ok(()) => {}
            Err(e) => {
                warn!("write error: {:?}", e);
                break;
            }
        };
         */
    }
    // info!("Exited message loop");
}

/*
Wifi scanning

We could use this to program the ssid config with a list of ssids, and when
it cannot connect via one, it scans to see if another one it knows is available
and then tries to connect to that.

let mut scanner = control.scan(Default::default()).await;
while let Some(bss) = scanner.next().await {
    if let Ok(ssid_str) = str::from_utf8(&bss.ssid) {
    info!("scanned {} == {:x}", ssid_str, bss.bssid);
    }
}

 */

#[embassy_executor::main]
async fn main(spawner: Spawner) {
    let p = embassy_rp::init(Default::default());
    let fw = include_bytes!("../assets/43439A0.bin");
    let clm = include_bytes!("../assets/43439A0_clm.bin");
    let pwr = Output::new(p.PIN_23, Level::Low);
    let cs = Output::new(p.PIN_25, Level::High);
    let mut pio = Pio::new(p.PIO0, Irqs);
    let spi = PioSpi::new(
        &mut pio.common,
        pio.sm0,
        pio.irq0,
        cs,
        p.PIN_24,
        p.PIN_29,
        p.DMA_CH0,
    );

    static STATE: StaticCell<cyw43::State> = StaticCell::new();
    let state = STATE.init(cyw43::State::new());
    let (net_device, mut control, runner) = cyw43::new(state, pwr, spi, fw).await;

    spawner.spawn(wifi_task(runner)).unwrap();

    control.init(clm).await;
    control
        .set_power_management(cyw43::PowerManagementMode::PowerSave)
        .await;

    // Get a unique device id - in this case an eight-byte ID from flash rendered as hex string
    let mut flash = Flash::<_, Async, { FLASH_SIZE }>::new(p.FLASH, p.DMA_CH1);
    let mut device_id = [0; 8];
    flash.blocking_unique_id(&mut device_id).unwrap();

    let dhcp_config = embassy_net::Config::dhcpv4(Default::default());

    static RESOURCES: StaticCell<StackResources<3>> = StaticCell::new();
    let resources = RESOURCES.init(StackResources::new());

    // Generate random seed
    let seed = 0x0123_4567_89ab_cdef;
    static STACK: StaticCell<Stack<NetDriver<'static>>> = StaticCell::new();
    let stack = STACK.init(Stack::new(net_device, dhcp_config, resources, seed));

    spawner.spawn(net_task(stack)).unwrap();

    let ssid_name = SSID_NAME[MARKER_LENGTH..(MARKER_LENGTH + SSID_NAME_LENGTH)].trim();
    let ssid_pass = SSID_PASS[MARKER_LENGTH..(MARKER_LENGTH + SSID_PASS_LENGTH)].trim();

    while let Some(ip_address) = join_wifi(&mut control, &stack, ssid_name, ssid_pass).await {
        loop {
            message_loop(device_id, ip_address, stack).await;
            info!("Disconnected");
        }
    }

    info!("Exiting");
}
