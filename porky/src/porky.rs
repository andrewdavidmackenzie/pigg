#![no_std]
#![no_main]

use crate::ssid::{MARKER_LENGTH, SSID_NAME, SSID_NAME_LENGTH, SSID_PASS, SSID_PASS_LENGTH};
use core::str::from_utf8;
use cyw43::Control;
use cyw43::NetDriver;
use cyw43_pio::PioSpi;
use defmt::{error, info};
use defmt_rtt as _;
use embassy_executor::Spawner;
use embassy_futures::select::{select, Either};
use embassy_net::tcp::TcpSocket;
use embassy_net::Ipv4Address;
use embassy_net::{
    tcp::client::{TcpClient, TcpClientState},
    Stack, StackResources,
};
use embassy_rp::bind_interrupts;
use embassy_rp::flash::Async;
use embassy_rp::flash::Flash;
use embassy_rp::gpio::Flex;
use embassy_rp::gpio::Pull;
use embassy_rp::gpio::{Level, Output};
use embassy_rp::peripherals::USB;
use embassy_rp::peripherals::{DMA_CH0, PIO0};
use embassy_rp::pio::{InterruptHandler, Pio};
use embassy_rp::usb::InterruptHandler as USBInterruptHandler;
use embassy_sync::blocking_mutex::raw::ThreadModeRawMutex;
use embassy_sync::channel::{Channel, Receiver, Sender};
use embassy_time::Instant;
use embedded_io_async::Write;
use faster_hex::hex_encode;
use heapless::FnvIndexMap;
use heapless::Vec;
use hw_definition::config::HardwareConfigMessage::*;
use hw_definition::config::{HardwareConfig, HardwareConfigMessage, InputPull, LevelChange};
use hw_definition::description::{HardwareDescription, HardwareDetails, PinDescriptionSet};
use hw_definition::pin_function::PinFunction;
use hw_definition::{BCMPinNumber, PinLevel};
use panic_probe as _;
use pin_descriptions::PIN_DESCRIPTIONS;
use static_cell::StaticCell;

/// The ssid config generated by build.rs in "$OUT_DIR/ssid.rs"
mod ssid {
    include!(concat!(env!("OUT_DIR"), "/ssid.rs"));
}

/// Wifi related functions
mod wifi;

#[path = "../../src/hw_definition/mod.rs"]
mod hw_definition;

mod pin_descriptions;

const FLASH_SIZE: usize = 2 * 1024 * 1024;

bind_interrupts!(struct Irqs {
    PIO0_IRQ_0 => InterruptHandler<PIO0>;
    USBCTRL_IRQ => USBInterruptHandler<USB>;
});

static RETURNER: Channel<ThreadModeRawMutex, Flex, 1> = Channel::new();
static SIGNALLER: Channel<ThreadModeRawMutex, bool, 1> = Channel::new();

static mut GPIO_PINS: FnvIndexMap<BCMPinNumber, GPIOPin, 32> = FnvIndexMap::new();

/// The configured/not-configured state of the GPIO Pins on the Pi Pico, and how to access them
/// as 3 of them are accessed via Cyw43 and others via gpio API
enum GPIOPin<'a> {
    Available(Flex<'a>),
    GPIOInput(
        (
            Sender<'a, ThreadModeRawMutex, bool, 1>,
            Receiver<'a, ThreadModeRawMutex, Flex<'a>, 1>,
        ),
    ),
    CYW43Input,
    CYW43Output,
    GPIOOutput(Flex<'a>),
}

struct AvailablePins {
    pin_3: embassy_rp::peripherals::PIN_3,
    pin_4: embassy_rp::peripherals::PIN_4,
    pin_5: embassy_rp::peripherals::PIN_5,
    pin_6: embassy_rp::peripherals::PIN_6,
    pin_7: embassy_rp::peripherals::PIN_7,
    pin_8: embassy_rp::peripherals::PIN_8,
    pin_9: embassy_rp::peripherals::PIN_9,
    pin_10: embassy_rp::peripherals::PIN_10,
    pin_11: embassy_rp::peripherals::PIN_11,
    pin_12: embassy_rp::peripherals::PIN_12,
    pin_13: embassy_rp::peripherals::PIN_13,
    pin_14: embassy_rp::peripherals::PIN_14,
    pin_15: embassy_rp::peripherals::PIN_15,
    pin_16: embassy_rp::peripherals::PIN_16,
    pin_17: embassy_rp::peripherals::PIN_17,
    pin_18: embassy_rp::peripherals::PIN_18,
    pin_19: embassy_rp::peripherals::PIN_19,
    pin_20: embassy_rp::peripherals::PIN_20,
    pin_21: embassy_rp::peripherals::PIN_21,
    pin_22: embassy_rp::peripherals::PIN_22,
    pin_26: embassy_rp::peripherals::PIN_26,
    pin_27: embassy_rp::peripherals::PIN_27,
    pin_28: embassy_rp::peripherals::PIN_28,
}

#[embassy_executor::task]
async fn wifi_task(
    runner: cyw43::Runner<'static, Output<'static>, PioSpi<'static, PIO0, 0, DMA_CH0>>,
) -> ! {
    runner.run().await
}

#[embassy_executor::task]
async fn net_task(stack: &'static Stack<NetDriver<'static>>) -> ! {
    stack.run().await
}

/// Wait until a level change on an input occurs and then send it via TCP to GUI
#[embassy_executor::task]
async fn monitor_input(
    _bcm_pin_number: BCMPinNumber,
    //    socket: &mut TcpSocket<'_>,
    signaller: Receiver<'static, ThreadModeRawMutex, bool, 1>,
    returner: Sender<'static, ThreadModeRawMutex, Flex<'static>, 1>,
    mut flex: Flex<'static>,
) {
    //    let _ = send_input_level(socket, bcm_pin_number, flex.get_level()).await;

    loop {
        match select(flex.wait_for_any_edge(), signaller.receive()).await {
            Either::First(()) => {
                info!("Level change detected");
                // send_input_level(socket, bcm_pin_number, flex.get_level()).await
            }
            Either::Second(_) => {
                info!("Monitor returning Pin");
                // Return the Flex pin and exit the task
                let _ = returner.send(flex);
                break;
            }
        }
    }
}

fn into_level(value: PinLevel) -> Level {
    match value {
        true => Level::High,
        false => Level::Low,
    }
}

/// Set an output's level using the bcm pin number
async fn set_output_level<'a>(
    control: &mut Control<'_>,
    bcm_pin_number: BCMPinNumber,
    pin_level: PinLevel,
) {
    info!(
        "Pin #{} Output level change: {:?}",
        bcm_pin_number, pin_level
    );

    // GPIO 0 and 1 are connected via cyw43 wifi chip
    unsafe {
        match GPIO_PINS.get_mut(&bcm_pin_number) {
            Some(GPIOPin::CYW43Output) => control.gpio_set(bcm_pin_number, pin_level).await,
            Some(GPIOPin::GPIOOutput(flex)) => flex.set_level(into_level(pin_level)),
            _ => error!("Pin {} is not configured as an Output", bcm_pin_number),
        }
    }
}

#[allow(dead_code)] // TODO remove when finish sending input levels
/// Send a detected input level change back to the GUI using `writer` [TcpStream],
/// timestamping with the current time in Utc
async fn send_input_level(socket: &mut TcpSocket<'_>, bcm: BCMPinNumber, level: Level) {
    let level_change = LevelChange::new(
        level == Level::High,
        Instant::now().duration_since(Instant::MIN).into(),
    );
    let hardware_event = IOLevelChanged(bcm, level_change);
    let mut buf = [0; 1024];
    let message = postcard::to_slice(&hardware_event, &mut buf).unwrap();
    socket.write_all(&message).await.unwrap();
}

/// Apply the requested config to one pin, using bcm_pin_number
async fn apply_pin_config<'a>(
    control: &mut Control<'_>,
    spawner: &Spawner,
    bcm_pin_number: BCMPinNumber,
    new_pin_function: &PinFunction,
    _socket: &mut TcpSocket<'_>,
) {
    let gpio_pin = unsafe {
        match GPIO_PINS.remove(&bcm_pin_number) {
            Some(GPIOPin::GPIOInput((signaller, returner))) => {
                // Signal to pin monitor to exit
                signaller.send(true).await;
                // Recover the Flex
                Some(returner.receive().await)
            }
            Some(GPIOPin::Available(flex)) | Some(GPIOPin::GPIOOutput(flex)) => Some(flex),
            Some(GPIOPin::CYW43Input) | Some(GPIOPin::CYW43Output) => None,
            _ => {
                error!("Could not find pin #{}", bcm_pin_number);
                return;
            }
        }
    };

    match new_pin_function {
        PinFunction::None => {
            // if pin 0, 1 or 2 - then have been removed and so are considered unconfigured
            if let Some(flex) = gpio_pin {
                unsafe {
                    let _ = GPIO_PINS.insert(bcm_pin_number, GPIOPin::Available(flex));
                }
            }
            info!("Pin #{} - Unconfigured", bcm_pin_number);
        }

        PinFunction::Input(pull) => {
            match gpio_pin {
                Some(mut flex) => {
                    flex.set_as_input();
                    info!("Pin #{} Configured as GPIO input", bcm_pin_number);

                    match pull {
                        None | Some(InputPull::None) => flex.set_pull(Pull::None),
                        Some(InputPull::PullUp) => flex.set_pull(Pull::Up),
                        Some(InputPull::PullDown) => flex.set_pull(Pull::Down),
                    };

                    spawner
                        .spawn(monitor_input(
                            bcm_pin_number,
                            //                            socket,
                            SIGNALLER.receiver(),
                            RETURNER.sender(),
                            flex,
                        ))
                        .unwrap();

                    unsafe {
                        let _ = GPIO_PINS.insert(
                            bcm_pin_number,
                            GPIOPin::GPIOInput((SIGNALLER.sender(), RETURNER.receiver())),
                        );
                    }
                }
                None => {
                    // Must be GPIO 2 is connected via cyw43 wifi chip
                    unsafe {
                        let _ = GPIO_PINS.insert(bcm_pin_number, GPIOPin::CYW43Input);
                    }
                    info!("Pin #{} - Configured as input via cyw43", bcm_pin_number);
                }
            }
        }

        PinFunction::Output(pin_level) => {
            match gpio_pin {
                Some(mut flex) => {
                    flex.set_as_output();
                    info!("Pin #{} Configured as GPIO output", bcm_pin_number);

                    if let Some(l) = pin_level {
                        flex.set_level(into_level(*l));
                        info!("Pin #{} - output level set to '{}'", bcm_pin_number, l);
                    }

                    unsafe {
                        let _ = GPIO_PINS.insert(bcm_pin_number, GPIOPin::GPIOOutput(flex));
                    }
                }
                None => {
                    // Must be GPIO 0 and 1 are connected via cyw43 wifi chip
                    info!("Pin #{} Configured as output via cyw43", bcm_pin_number);

                    if let Some(l) = pin_level {
                        control.gpio_set(bcm_pin_number, *l).await;
                        info!(
                            "Pin #{} - output level set to '{}'",
                            bcm_pin_number, pin_level
                        );
                    }
                    unsafe {
                        let _ = GPIO_PINS.insert(bcm_pin_number, GPIOPin::CYW43Output);
                    }
                }
            }
        }
    }
}

/// This takes the GPIOConfig struct and configures all the pins in it
async fn apply_config<'a>(
    control: &mut Control<'_>,
    spawner: &Spawner,
    config: &HardwareConfig,
    socket: &mut TcpSocket<'_>,
) {
    // Config only has pins that are configured
    for (bcm_pin_number, pin_function) in &config.pin_functions {
        apply_pin_config(control, spawner, *bcm_pin_number, pin_function, socket).await;
    }
    info!("New config applied");
}

/// Apply a config change to the hardware
/// NOTE: Initially the callback to Config/PinConfig change was async, and that compiles and runs
/// but wasn't working - so this uses a sync callback again to fix that, and an async version of
/// send_input_level() for use directly from the async context
async fn apply_config_change<'a>(
    control: &mut Control<'_>,
    spawner: &Spawner,
    config_change: HardwareConfigMessage,
    socket: &mut TcpSocket<'_>,
) {
    match config_change {
        NewConfig(config) => apply_config(control, spawner, &config, socket).await,
        NewPinConfig(bcm, pin_function) => {
            apply_pin_config(control, spawner, bcm, &pin_function, socket).await
        }
        IOLevelChanged(bcm, level_change) => {
            set_output_level(control, bcm, level_change.new_level).await;
        }
    }
}

/// Wait for an incoming TCP connection, then respond to it with the [HardwareDescription]
async fn tcp_accept(socket: &mut TcpSocket<'_>, ip_address: &Ipv4Address, device_id: &[u8; 8]) {
    let mut buf = [0; 4096];

    info!("Listening on TCP {}:1234", ip_address);
    if let Err(e) = socket.accept(1234).await {
        error!("TCP accept error: {:?}", e);
        return;
    }

    info!(
        "Received connection from {:?}",
        socket.remote_endpoint().unwrap()
    );

    let mut device_id_hex: [u8; 16] = [0; 16];
    hex_encode(device_id, &mut device_id_hex).unwrap();

    // send hardware description
    let details = HardwareDetails {
        hardware: "foo",
        revision: "foo",
        serial: from_utf8(&device_id_hex).unwrap(),
        model: "Pi Pico W",
    };

    let hw_desc = HardwareDescription {
        details,
        pins: PinDescriptionSet {
            pins: Vec::from_slice(&PIN_DESCRIPTIONS).unwrap(),
        },
    };

    let slice = postcard::to_slice(&hw_desc, &mut buf).unwrap();
    info!("Sending hardware description (length: {})", slice.len());
    socket.write_all(slice).await.unwrap();
}

/// Wait until a config message in received on the [TcpSocket] then deserialize it and return it
/// or return `None` if the connection was broken
async fn wait_message(socket: &mut TcpSocket<'_>) -> Option<HardwareConfigMessage> {
    let mut buf = [0; 4096]; // TODO needed?

    let n = socket.read(&mut buf).await.ok()?;
    if n == 0 {
        info!("Connection broken");
        return None;
    }

    postcard::from_bytes(&buf[..n]).ok()
}

/// Wait for a TCP connection to be made to this device
async fn wait_for_connection<'a>(
    stack: &'a Stack<NetDriver<'static>>,
    device_id: [u8; 8],
    ip_address: Ipv4Address,
    rx_buffer: &'a mut [u8],
    tx_buffer: &'a mut [u8],
) -> TcpSocket<'a> {
    // TODO check these are needed
    let client_state: TcpClientState<2, 1024, 1024> = TcpClientState::new();
    let _client = TcpClient::new(stack, &client_state);

    let mut socket = TcpSocket::new(stack, tx_buffer, rx_buffer);
    //socket.set_timeout(Some(Duration::from_secs(10)));

    // wait for an incoming TCP connection
    tcp_accept(&mut socket, &ip_address, &device_id).await;

    info!("Received incoming TCP connection");
    socket
}

/// Enter the message loop, processing config change messages received over TCP
async fn message_loop<'a>(control: &mut Control<'_>, spawner: &Spawner, mut socket: TcpSocket<'_>) {
    info!("Entering message loop");
    while let Some(config_message) = wait_message(&mut socket).await {
        apply_config_change(control, spawner, config_message, &mut socket).await;
    }
}

/// Take the set of available pins not used by other functions, including the three pins that
/// are connected via the CYW43 Wi-Fi chip. Create [Flex] Pins out of each of the GPIO pins.
/// Put them all into the GPIO_PINS map, marking them as available
fn setup_gpio_pins<'a>(available_pins: AvailablePins) {
    unsafe {
        let _ = GPIO_PINS.insert(0, GPIOPin::CYW43Output); // GP0 connected to CYW43 chip
        let _ = GPIO_PINS.insert(1, GPIOPin::CYW43Output); // GP1 connected to CYW43 chip
        let _ = GPIO_PINS.insert(2, GPIOPin::CYW43Input); // GP2 connected to CYW43 chip
        let _ = GPIO_PINS.insert(3, GPIOPin::Available(Flex::new(available_pins.pin_3)));
        let _ = GPIO_PINS.insert(4, GPIOPin::Available(Flex::new(available_pins.pin_4)));
        let _ = GPIO_PINS.insert(5, GPIOPin::Available(Flex::new(available_pins.pin_5)));
        let _ = GPIO_PINS.insert(6, GPIOPin::Available(Flex::new(available_pins.pin_6)));
        let _ = GPIO_PINS.insert(7, GPIOPin::Available(Flex::new(available_pins.pin_7)));
        let _ = GPIO_PINS.insert(8, GPIOPin::Available(Flex::new(available_pins.pin_8)));
        let _ = GPIO_PINS.insert(9, GPIOPin::Available(Flex::new(available_pins.pin_9)));
        let _ = GPIO_PINS.insert(10, GPIOPin::Available(Flex::new(available_pins.pin_10)));
        let _ = GPIO_PINS.insert(11, GPIOPin::Available(Flex::new(available_pins.pin_11)));
        let _ = GPIO_PINS.insert(12, GPIOPin::Available(Flex::new(available_pins.pin_12)));
        let _ = GPIO_PINS.insert(13, GPIOPin::Available(Flex::new(available_pins.pin_13)));
        let _ = GPIO_PINS.insert(14, GPIOPin::Available(Flex::new(available_pins.pin_14)));
        let _ = GPIO_PINS.insert(15, GPIOPin::Available(Flex::new(available_pins.pin_15)));
        let _ = GPIO_PINS.insert(16, GPIOPin::Available(Flex::new(available_pins.pin_16)));
        let _ = GPIO_PINS.insert(17, GPIOPin::Available(Flex::new(available_pins.pin_17)));
        let _ = GPIO_PINS.insert(18, GPIOPin::Available(Flex::new(available_pins.pin_18)));
        let _ = GPIO_PINS.insert(19, GPIOPin::Available(Flex::new(available_pins.pin_19)));
        let _ = GPIO_PINS.insert(20, GPIOPin::Available(Flex::new(available_pins.pin_20)));
        let _ = GPIO_PINS.insert(21, GPIOPin::Available(Flex::new(available_pins.pin_21)));
        let _ = GPIO_PINS.insert(22, GPIOPin::Available(Flex::new(available_pins.pin_22)));
        let _ = GPIO_PINS.insert(26, GPIOPin::Available(Flex::new(available_pins.pin_26)));
        let _ = GPIO_PINS.insert(27, GPIOPin::Available(Flex::new(available_pins.pin_27)));
        let _ = GPIO_PINS.insert(28, GPIOPin::Available(Flex::new(available_pins.pin_28)));
    }
}

#[embassy_executor::main]
async fn main(spawner: Spawner) {
    let peripherals = embassy_rp::init(Default::default());
    let fw = include_bytes!("../assets/43439A0.bin");
    let clm = include_bytes!("../assets/43439A0_clm.bin");
    let pwr = Output::new(peripherals.PIN_23, Level::Low);
    let cs = Output::new(peripherals.PIN_25, Level::High);
    let mut pio = Pio::new(peripherals.PIO0, Irqs);
    let spi = PioSpi::new(
        &mut pio.common,
        pio.sm0,
        pio.irq0,
        cs,
        peripherals.PIN_24,
        peripherals.PIN_29,
        peripherals.DMA_CH0,
    );

    // Take the following pins out of peripherals for use a GPIO
    let available_pins = AvailablePins {
        pin_3: peripherals.PIN_3,
        pin_4: peripherals.PIN_4,
        pin_5: peripherals.PIN_5,
        pin_6: peripherals.PIN_6,
        pin_7: peripherals.PIN_7,
        pin_8: peripherals.PIN_8,
        pin_9: peripherals.PIN_9,
        pin_10: peripherals.PIN_10,
        pin_11: peripherals.PIN_11,
        pin_12: peripherals.PIN_12,
        pin_13: peripherals.PIN_13,
        pin_14: peripherals.PIN_14,
        pin_15: peripherals.PIN_15,
        pin_16: peripherals.PIN_16,
        pin_17: peripherals.PIN_17,
        pin_18: peripherals.PIN_18,
        pin_19: peripherals.PIN_19,
        pin_20: peripherals.PIN_20,
        pin_21: peripherals.PIN_21,
        pin_22: peripherals.PIN_22,
        pin_26: peripherals.PIN_26,
        pin_27: peripherals.PIN_27,
        pin_28: peripherals.PIN_28,
    };

    static STATE: StaticCell<cyw43::State> = StaticCell::new();
    let state = STATE.init(cyw43::State::new());
    let (net_device, mut control, runner) = cyw43::new(state, pwr, spi, fw).await;

    spawner.spawn(wifi_task(runner)).unwrap();

    control.init(clm).await;
    control
        .set_power_management(cyw43::PowerManagementMode::PowerSave)
        .await;

    // Get a unique device id - in this case an eight-byte ID from flash rendered as hex string
    let mut flash = Flash::<_, Async, { FLASH_SIZE }>::new(peripherals.FLASH, peripherals.DMA_CH1);
    let mut device_id = [0; 8];
    flash.blocking_unique_id(&mut device_id).unwrap();

    let dhcp_config = embassy_net::Config::dhcpv4(Default::default());

    static RESOURCES: StaticCell<StackResources<3>> = StaticCell::new();
    let resources = RESOURCES.init(StackResources::new());

    // Generate random seed
    let seed = 0x0123_4567_89ab_cdef;
    static STACK: StaticCell<Stack<NetDriver<'static>>> = StaticCell::new();
    let stack = STACK.init(Stack::new(net_device, dhcp_config, resources, seed));
    spawner.spawn(net_task(stack)).unwrap();

    setup_gpio_pins(available_pins);

    let ssid_name = SSID_NAME[MARKER_LENGTH..(MARKER_LENGTH + SSID_NAME_LENGTH)].trim();
    let ssid_pass = SSID_PASS[MARKER_LENGTH..(MARKER_LENGTH + SSID_PASS_LENGTH)].trim();

    let mut rx_buffer = [0; 4096];
    let mut tx_buffer = [0; 4096];

    while let Some(ip_address) = wifi::join(&mut control, &stack, ssid_name, ssid_pass).await {
        loop {
            let socket =
                wait_for_connection(stack, device_id, ip_address, &mut tx_buffer, &mut rx_buffer)
                    .await;
            message_loop(&mut control, &spawner, socket).await;
            info!("Disconnected");
        }
    }

    info!("Exiting");
}
